# Classwork6
Да, каюсь, использовал частично ии, ну потому-что глупенький и сам ничего вообще не понимаю в си шарпе

```
Завдання 1
Що робить:
Метод ParseSetting розбиває рядок формату ключ=значення на ключ і значення.
Перевіряє, чи рядок не порожній і не null — якщо порожній, викликає ArgumentNullException.
Перевіряє наявність символу = — якщо його немає, викликає FormatException.
Автоматично обрізає пробіли навколо ключа і значення.
Використовує [CallerArgumentExpression], щоб у повідомленні про помилку підставлялося ім’я параметра.

На що звернути увагу:
Метод автоматично обрізає пробіли навколо ключа та значення.
Рядок повинен містити символ =; інакше буде FormatException.
Порожні рядки або null викликають ArgumentNullException.
[CallerArgumentExpression] дозволяє точніше вказувати параметр, що спричинив помилку.
```

```
Завдання 2
Що робить:
Програма демонструє роботу перевірки переповнення  і обчислень без перевірки  у C#.
Метод AddChecked додає два числа з перевіркою переповненн. Якщо результат перевищує межі int, викликається OverflowException.
Метод AddWrapped додає два числа без перевірки переповнення, результат "завертається" за межі типу.
Метод SumAll обчислює суму масиву чисел і може працювати у безпечному або небезпечному режимі, використовуючи checked або unchecked для кожного додавання.
У Main демонструється виклик обох методів і обробка переповнення через try-catch.

На що звернути увагу:
checked викликає виняток при переповненні чисел типу int.
unchecked дозволяє "завертання" чисел при переповненні, без винятків.
У методі SumAll можна динамічно обирати безпечний або небезпечний режим.
При використанні int.MaxValue + 1 у checked отримаємо OverflowException, а в unchecked — число "обернеться" в мінімальне значення типу.
```

```
Завдання 3

Що робить:
Клас TempFileWriter створює текстовий файл у папці проєкту.
Метод WriteLine(string) записує рядки у файл.
Після виклику Dispose() файл закривається, і подальший запис спричиняє ObjectDisposedException.
Демонструє роботу IDisposable та конструкції using.
Варіант AsyncFileCopier показує асинхронне звільнення ресурсів через IAsyncDisposable і await using.


Як запустити:
Запустити
Перевірити, що створився файл test.txt у папці проєкту. (Знаходиться приблизно
за посиланням ConsoleApp1\ConsoleApp1\bin\Debug\net8.0\test.txt)

На що звернути увагу:
Dispose() викликається автоматично при виході з блоку using.
Після звільнення ресурсів будь-який доступ до об’єкта викликає виняток.
В асинхронній версії використовується await using і коректне оброблення OperationCanceledException
```

```
Завдання 4
Що робить:
Функція Transform приймає рядок і стратегію обробки.
Реалізовано дві стратегії:
TrimToUpper — обрізає пробіли та переводить у верхній регістр.
MaskDigits — замінює всі цифри на *.
У середньому рівні клас TextFormatter зберігає поточну стратегію (Func<string,string> Strategy) і застосовує її до всіх рядків (FormatAll).
Демонструється зміна стратегії «на льоту» через лямбди.

Як запустити:
Створити консольний проєкт.
Вставити код з прикладу.
Запустити і спостерігати, як один і той самий список форматують різні стратегії.

На що звернути увагу:
Делегати Func<> дозволяють передавати поведінку як параметр.
Лямбда-вирази (s => ...) — короткий спосіб оголосити функцію прямо в коді.
Усі виклики відбуваються без загальних catch, лише з локальними перевірками.
```